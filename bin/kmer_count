#!/usr/bin/env python3

'''
@author: Gabriele Girelli
@contact: gigi.ga90@gmail.com
@description: script to count k-mer abundance
'''

import argparse
import kman as km
import oligo_melting as om
import os
import sys
import tempfile

parser = argparse.ArgumentParser(description = '''
Count occurrences of all k-mer (i.e., k-characters substrings) that appear in
the input sequence. Depending on the mode, a different output is generated:

         SEQ_COUNT a tabulation-separated table with sequence and count

         VEC_COUNT a vector for each record in the input fasta, containing the
                   occurrence count of each k-mer (start position-bound)

  VEC_COUNT_MASKED a vector for each record in the input fasta, containing the
                   occurrence count of each k-mer (start position-bound). Only
                   occurrences in other records are counted.

When using a VEC_* mode, the output will be stored in a folder with the name of
the specified output, after removing the extension.
''', formatter_class = argparse.RawDescriptionHelpFormatter)

parser.add_argument('input', type = str, help = '''
Path to input fasta file. Can be gzipped (ending in ".gz")''')
parser.add_argument('output', type = str, help = '''
	Path to output tsv file.''')
parser.add_argument('-k', type = int, required = True,
	help = '''Oligonucleotide (substring) length in nucleotides.''')

parser.add_argument('-m', type = str,
	help = '''Choose counting mode. See description for more details.
	Default: "%s"''' % km.join.KJoiner.MODE.SEQ_COUNT.name,
	default = km.join.KJoiner.MODE.SEQ_COUNT.name,
	choices = [m for m in dir(km.join.KJoiner.MODE) if "COUNT" in m])
parser.add_argument('-b', type = int, default = 1e6,
	help = '''Number of kmers per batch. Default: 1e6''')
parser.add_argument('-t', type = int, default = 1,
	help = '''Number of threads for parallelization.''')
parser.add_argument('-T', type = str, default = tempfile.gettempdir(),
	help = '''Temporary folder path. Default: "%s"''' % tempfile.gettempdir())
parser.add_argument('-B', type = str, help = '''Path to folder with previously
	generated batches. Useful to skip the batching step.''')

parser.add_argument('-r', dest = 'do_records',
	action = 'store_const', const = True, default = False,
	help = '''Force parallelization over records instead of k-mers. Particularly
	helpful for fasta files with many "short" records.''')
parser.add_argument('-R', dest = 'do_reverse', action = 'store_const',
	const = True, default = False, help = '''Reverse complement sequences.''')

version = "0.0.1"
parser.add_argument('--version', action = 'version',
	version = '%s v%s' % (sys.argv[0], version,))

args = parser.parse_args()

assert_msg = "path to an existing fasta file expected, file not found: '%s'" % (
	args.input); assert os.path.isfile(args.input), assert_msg

if not os.path.isdir(args.T): os.makedirs(args.T, exist_ok = True)
tempfile.tempdir = args.T

args.m = km.join.KJoiner.MODE[args.m]

if type(None) != type(args.B):
	assert_msg = "batching output folder not found: '%s'" % args.B
	assert os.path.isdir(args.B), assert_msg
	assert_msg = "the batching output folder is empty: '%s'" % args.B
	assert 0 < len(os.listdir(args.B)), assert_msg

# RUN ==========================================================================

if type(None) != type(args.B):
	print("Loading previously generated batches from '%s'..." % args.B)
	batches = [km.batch.Batch.from_file(os.path.join(args.B, fname))
		for fname in os.listdir(args.B)]
else:
	batcher = km.batch.FastaBatcher(size = args.b, threads = args.t)
	if args.do_records: batcher.mode = batcher.MODE.RECORDS
	batcher.doReverseComplement = args.do_reverse
	batcher.do(args.input, args.k)
	batches = batcher.collection

print("Joining...")
joiner = km.join.KJoinerThreading(args.m)
joiner.threads = args.t
joiner.batch_size = max(2, int(len(batches) / args.t))
joiner.join(batches, args.output)

# END ==========================================================================

################################################################################
