#!/usr/bin/env python3

"""
@author: Gabriele Girelli
@contact: gigi.ga90@gmail.com
@description: script to count k-mer abundance
"""

import argparse
import kman as km
import oligo_melting as om
import os
import resource
import sys
import tempfile
from tqdm import tqdm

parser = argparse.ArgumentParser(
    description="""
Count occurrences of all k-mer (i.e., k-characters substrings) that appear in
the input sequence. Depending on the mode, a different output is generated:

         SEQ_COUNT a tabulation-separated table with sequence and count

         VEC_COUNT a vector for each record in the input fasta, containing the
                   occurrence count of each k-mer (start position-bound)

  VEC_COUNT_MASKED a vector for each record in the input fasta, containing the
                   occurrence count of each k-mer (start position-bound). Only
                   occurrences in other records are counted.

When using a VEC_* mode, the output will be stored in a folder with the name of
the specified output, after removing the extension.
""",
    formatter_class=argparse.RawDescriptionHelpFormatter,
)

parser.add_argument(
    "input",
    type=str,
    help="""
Path to input fasta file. Can be gzipped (ending in ".gz")""",
)
parser.add_argument(
    "output",
    type=str,
    help="""
	Path to output tsv file.""",
)
parser.add_argument(
    "-k",
    type=int,
    required=True,
    help="""Oligonucleotide (substring) length in nucleotides.""",
)

parser.add_argument(
    "-s",
    type=str,
    help='''Choose scanning mode. See description for more details.
	Default: "%s"'''
    % km.batcher.FastaBatcher.MODE.KMERS.name,
    default=km.batcher.FastaBatcher.MODE.KMERS.name,
    choices=[m.name for m in list(km.batcher.FastaBatcher.MODE)],
)
parser.add_argument(
    "-m",
    type=str,
    help='''Choose batching mode. See description for more details.
	Default: "%s"'''
    % km.batcher.BatcherThreading.FEED_MODE.APPEND.name,
    default=km.batcher.BatcherThreading.FEED_MODE.APPEND.name,
    choices=[m.name for m in list(km.batcher.BatcherThreading.FEED_MODE)],
)
parser.add_argument(
    "-b", type=int, default=1e6, help="""Number of kmers per batch. Default: 1e6"""
)
parser.add_argument(
    "-B",
    type=str,
    help="""Path to folder with previously
	generated batches. Useful to skip the batching step.""",
)
parser.add_argument(
    "-c",
    type=str,
    help='''Choose counting mode. See description for more details.
	Default: "%s"'''
    % km.join.KJoiner.MODE.SEQ_COUNT.name,
    default=km.join.KJoiner.MODE.SEQ_COUNT.name,
    choices=[m.name for m in list(km.join.KJoiner.MODE) if "COUNT" in m.name],
)
parser.add_argument(
    "-M",
    type=str,
    help='''Choose memory mode. See description for more details.
	Default: "%s"'''
    % km.join.KJoiner.MEMORY.NORMAL.name,
    default=km.join.KJoiner.MEMORY.NORMAL.name,
    choices=[m.name for m in list(km.join.KJoiner.MEMORY)],
)
parser.add_argument(
    "-t", type=int, default=1, help="""Number of threads for parallelization."""
)
parser.add_argument(
    "-T",
    type=str,
    default=tempfile.gettempdir(),
    help='''Temporary folder path. Default: "%s"''' % tempfile.gettempdir(),
)

parser.add_argument(
    "-R",
    dest="do_reverse",
    action="store_const",
    const=True,
    default=False,
    help="""Reverse complement sequences.""",
)

parser.add_argument(
    "--resort",
    dest="do_resort",
    action="store_const",
    const=True,
    default=False,
    help="""Force batch re-sorting, when loaded
	with -B.""",
)

version = "0.0.1"
parser.add_argument(
    "--version",
    action="version",
    version="%s v%s"
    % (
        sys.argv[0],
        version,
    ),
)

args = parser.parse_args()

assert_msg = "path to an existing fasta file expected, file not found: '%s'" % (
    args.input
)
assert os.path.isfile(args.input), assert_msg

if not os.path.isdir(args.T):
    os.makedirs(args.T, exist_ok=True)
tempfile.tempdir = args.T

args.s = km.batcher.FastaBatcher.MODE[args.s]
args.m = km.batcher.BatcherThreading.FEED_MODE[args.m]
args.c = km.join.KJoiner.MODE[args.c]
args.M = km.join.KJoiner.MEMORY[args.M]

if type(None) != type(args.B):
    assert_msg = "batching output folder not found: '%s'" % args.B
    assert os.path.isdir(args.B), assert_msg
    assert_msg = "the batching output folder is empty: '%s'" % args.B
    assert 0 < len(os.listdir(args.B)), assert_msg

# RUN ==========================================================================

if type(None) != type(args.B):
    print("Loading previously generated batches from '%s'..." % args.B)
    batches = km.batcher.BatcherThreading.from_files(
        args.B, args.t, reSort=args.do_resort
    )
else:
    batcher = km.batcher.FastaBatcher(size=args.b, threads=args.t)
    batcher.mode = args.s
    batcher.doReverseComplement = args.do_reverse
    batcher.do(args.input, args.k, args.m)
    batches = batcher.collection

joiner = km.join.KJoinerThreading(args.c, args.M)
joiner.threads = args.t

joiner.batch_size = max(2, int(len(batches) / args.t))
rlimits = resource.getrlimit(resource.RLIMIT_NOFILE)
joiner.batch_size = min(joiner.batch_size, rlimits[1])
resource.setrlimit(
    resource.RLIMIT_NOFILE, (max(rlimits[0], joiner.batch_size), rlimits[1])
)

joiner.join(batches, args.output)

# END ==========================================================================

################################################################################
