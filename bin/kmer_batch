#!/usr/bin/env python3

'''
@author: Gabriele Girelli
@contact: gigi.ga90@gmail.com
@description: script to count k-mer abundance
'''

import argparse
import gzip
import kman as km
import oligo_melting as om
import os
import shutil
import sys
import tempfile

parser = argparse.ArgumentParser(description = '''
Generate batches of k-mers from a fasta file.
''', formatter_class = argparse.RawDescriptionHelpFormatter)

parser.add_argument('input', type = str, help = '''
Path to input fasta file. Can be gzipped (ending in ".gz")''')
parser.add_argument('output', type = str, help = '''
	Path to output folder, which must be emtpy or non-existent.''')
parser.add_argument('-k', type = int, required = True,
	help = '''Oligonucleotide (substring) length in nucleotides.''')

parser.add_argument('-m', type = str,
	help = '''Choose batching mode. See description for more details.
	Default: "%s"''' % km.batch.BatcherThreading.FEED_MODE.APPEND.name,
	default = km.batch.BatcherThreading.FEED_MODE.APPEND.name,
	choices = [m.name for m in list(km.batch.BatcherThreading.FEED_MODE)])
parser.add_argument('-b', type = int, default = 1e6,
	help = '''Number of kmers per batch. Default: 1e6''')
parser.add_argument('-t', type = int, default = 1,
	help = '''Number of threads for parallelization.''')
parser.add_argument('-T', type = str, default = tempfile.gettempdir(),
	help = '''Temporary folder path. Default: "%s"''' % tempfile.gettempdir())

parser.add_argument('-r', dest = 'do_records',
	action = 'store_const', const = True, default = False,
	help = '''Force parallelization over records instead of k-mers. Particularly
	helpful for fasta files with many "short" records.''')
parser.add_argument('-R', dest = 'do_reverse', action = 'store_const',
	const = True, default = False, help = '''Reverse complement sequences.''')
parser.add_argument('-C', dest = 'do_compress', action = 'store_const',
	const = True, default = False, help = '''Compress output files.''')

version = "0.0.1"
parser.add_argument('--version', action = 'version',
	version = '%s v%s' % (sys.argv[0], version,))

args = parser.parse_args()

args.o = args.output

assert_msg = "path to an existing fasta file expected, file not found: '%s'" % (
	args.input); assert os.path.isfile(args.input), assert_msg

assert_msg = "output folder must be empty or non-existent."
if os.path.isdir(args.o):
	assert 0 == len(os.listdir(args.o)), assert_msg

if not os.path.isdir(args.T): os.makedirs(args.T, exist_ok = True)
tempfile.tempdir = args.T

args.m = km.batcher.BatcherThreading.FEED_MODE[args.m]

# RUN ==========================================================================

batcher = km.batcher.FastaBatcher(size = args.b, threads = args.t)
if args.do_records: batcher.mode = batcher.MODE.RECORDS
batcher.doReverseComplement = args.do_reverse
batcher.do(args.input, args.k, args.m)
os.makedirs(args.o, exist_ok = True)

try:
	batchList = tqdm([b for b in batcher.collection if os.path.isfile(b.tmp)])
	if args.do_compress:
		for b in batchList:
			gzname = os.path.join(args.o, "%s.gz" % os.path.basename(b.tmp))
			OH = gzip.open(gzname, "wb")
			IH = open(b.tmp, "rb")
			for line in IH:
				OH.write(line)
			IH.close()
			OH.close()
	else:
		for b in batchList:
			shutil.copy(b.tmp, args.o)
except IOError as e:
	print("Unable to write to output directory '%s'.\n%s" % (args.o, e))
except:
	print("Unexpected error:", sys.exc_info())

# END ==========================================================================

################################################################################
