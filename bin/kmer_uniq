#!/usr/bin/env python3

'''
@author: Gabriele Girelli
@contact: gigi.ga90@gmail.com
@description: script to identify uniquely occurring k-mers
'''

import argparse
import kman as km
import oligo_melting as om
import os
import sys
import tempfile

parser = argparse.ArgumentParser(description = '''
Extract all k-mer (i.e., k-characters substrings) that appear in the input
sequence only once.''', formatter_class = argparse.RawDescriptionHelpFormatter)

parser.add_argument('input', type = str, help = '''
	Path to input fasta file. Can be gzipped (ending in ".gz")''')
parser.add_argument('output', type = str, help = '''
	Path to output fasta file.''')
parser.add_argument('-k', type = int, required = True,
	help = '''Oligonucleotide (substring) length in nucleotides.''')

parser.add_argument('-b', type = int, default = 1e6,
	help = '''Number of kmers per batch. Default: 1e6''')
parser.add_argument('-t', type = int, default = 1,
	help = '''Number of threads for parallelization.''')
parser.add_argument('-T', type = str, default = tempfile.gettempdir(),
	help = '''Temporary folder path. Default: "%s"''' % tempfile.gettempdir())
parser.add_argument('-B', type = str, help = '''Path to folder with previously
	generated batches. Useful to skip the batching step.''')

parser.add_argument('-r', dest = 'do_records',
	action = 'store_const', const = True, default = False,
	help = '''Force parallelization over records instead of k-mers. Particularly
	helpful for fasta files with many "short" records.''')
parser.add_argument('-R', dest = 'do_reverse', action = 'store_const',
	const = True, default = False, help = '''Reverse complement sequences.''')

version = "0.0.2"
parser.add_argument('--version', action = 'version',
	version = '%s v%s' % (sys.argv[0], version,))

args = parser.parse_args()

assert_msg = "path to an existing fasta file expected, file not found: '%s'" % (
	args.input); assert os.path.isfile(args.input), assert_msg

if not os.path.isdir(args.T): os.makedirs(args.T, exist_ok = True)
tempfile.tempdir = args.T

if type(None) != type(args.B):
	assert_msg = "batching output folder not found: '%s'" % args.B
	assert os.path.isdir(args.B), assert_msg
	assert_msg = "the batching output folder is empty: '%s'" % args.B
	assert 0 < len(os.listdir(args.B)), assert_msg

# RUN ==========================================================================

if type(None) != type(args.B):
	print("Loading previously generated batches from '%s'..." % args.B)
	batches = km.batch.BatcherThreading.from_files(args.B, args.t)
else:
	batcher = km.batch.FastaBatcher(size = args.b, threads = args.t)
	if args.do_records: batcher.mode = batcher.MODE.RECORDS
	batcher.do(args.input, args.k)
	batcher.doReverseComplement = args.do_reverse
	batches = batcher.collection

print("Joining...")
joiner = km.join.KJoinerThreading()
joiner.threads = args.t
joiner.batch_size = max(2, int(len(batches) / args.t))
joiner.join(batches, args.output)

# END ==========================================================================

################################################################################
